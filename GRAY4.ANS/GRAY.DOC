Copyright 1990, 1991, 1994 Martin Anton Ertl

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

GRAY USERS MANUAL
==== ===== ======

To understand this manual you should know Forth and language
descriptions in BNF or similar syntax notations. Apologies for my
clumsy use of the English language.


USES FOR GRAY

Syntactic Analysis of Programming Languages (parsers)
It should not be hard to generate parsers for most programming
languages with Gray, but you will probably have to transform the
grammar (See the chapter on grammar massaging).

Lexical Analysis (scanners)
Although it is possible to use Gray for scanning, it's probably
overkill and there may be better methods.


GRAMMARS

Grammars describe the syntax of languages. A parser generator
translates grammars into parsers that can read all valid sentences
(programs, if we are talking about programming languages) of the
language. Computer scientists also say that the grammar derives the
sentences. Some grammatical expressions (syntax expressions) derive
the empty sentence, which is denoted by 'eps'.

The following table shows Gray's syntax expressions (a, b, and c
denote such expressions)

name		syntax		parses		example
---------------------------------------------------------------
concatenation	(( a b ... ))	a, then b, ...	(( "begin" word-list "until" ))
alternative    (( a || b ... ))	a or b ...	(( word || number ))
eps		eps		eps		eps
option		a ??		zero or one a	(( "else" word-list )) ??
*-repetition	a **		zero or more a	word **
+-repetition	a ++		one or more a	char ++
nonterminal	name		See text	word-list
terminal	name		See text	"begin"
action	       {{ forth-code }}	eps		{{ . }}

You need not parenthesize a concatenation in an alternative;
(( a b || c )) is the same as (( (( a b )) || c ))


Terminals and the I/O Interface

The atomic units processed by a parser are the terminal symbols. They
are delivered by the underlying input layer and can be as complex as
you like: single characters, words, etc.

Gray and its parsers distinguish terminal symbols by their tokens (A
token is an unsigned number).

The input layer should read one symbol in advance to allow the parser
to base decisions on the token of the next symbol.

The Interface to the input layer consists of

1) the variable test-vector; there you should store the execution
address (cfa) of a word (let's call it test?) with the stack effect
( set -- f ). test? checks, if set contains the token of the next
symbol. You can use member? ( set u -- f ) to test u for membership in
set. If the parser generated by gray is too slow, it helps to optimize
test?, which is executed at least once for every symbol read,

2) the defining-word terminal ( set cfa -- )
	token singleton ' check&read terminal name 
declares the word name, which can then be used in the grammar, where
token's terminal symbol should be parsed. (Before you call singleton,
or any other set words, you should declare the maximum set size (and
thus the maximum token value) with max-member ( u -- ).) You have to
define check&read ( f -- ) which later is built into the parser and
called, when the symbol is to be parsed. At that time check&read must
read the next symbol. check&read also checks for syntax errors, which
are indicated by f being false (See the section on error handling).
check&reads for special symbols, e.g.  numbers, probably will perform
additional functions, e.g. pushing the value of the number (then
check&read's stack effect is ( f -- n )).


Nonterminals and Rules

	a <- name		(1)
or
	nonterminal name	(2)
	a name rule		(3)
can be used to define name as an abbreviation for a.
(1) and (3) are rules for the nonterminal "name", (1) and (2) are
declarations. After its declaration "name" can be used instead of "a".
This also allows recursive definitions.


Actions

are needed to turn a simple parser into an interpreter or a compiler.
For parsing they behave like eps, but when they are parsed, they
execute forth code. Example: if "num" parses a number and pushes its
value, then
	(( num {{ . }} ))
parses a number and prints it.

You may use the parameter stack as you like; therefore you should
write stack comments for every rule. You can use the return stack, but
the action should have no overall return stack effect.


Parser

You can generate the parser called "name" for the syntax expression
"a" with the defining word "parser":
	a parser name
All nonterminals have to be defined; the generation may take a while
if the grammar is large.


DISAMBIGUATING RULES

Grays parsers try to predict from the next token, which expression
they should parse. For some grammars this is not possible--there is an
ambiguity. Gray generates parsers anyway, but they probably won't
parse every sentence of the language. In ambiguous cases the parsers
decide according to the following rules:
In an alternative the earlier branches have higher precedence, but an
eps-derivation is chosen only if no branch begins with the current
token.

The argument of options are rather parsed than not, but if it cannot
begin with the current token, it is skipped, even if it can parse eps.
This may seem unimportant, since the language remains the same, but if
there are actions to be executed, the results need not be what you
wanted.

The operand of a repetition is parsed as often as seems possible, but
again the repetition is left, if only empty sentences can be parsed.
However, the argument of the +-repetition is parsed at least once.


WARNINGS AND ERROR MESSAGES

Most error messages tell you where they happened. For concatenations
and alternatives the position of "||" or "))" are displayed.

Errors while reading the grammar

no operand
There is no grammar expression between "((" and "))", "((" and "||",
"||" and "||", or "||" and "))". Insert eps, if you want to parse the
empty sentence.

multiple rules for nonterminal
There may be only one rule for every nonterminal. Use the alternative.

Error messages while generating the parser

no rule for nonterminal
A nonterminal was declared and used, but there is no rule for it.

left recursion 
The grammar contains a left recursion , i.e. the parser could recurse
without having parsed a terminal symbol. This situation would lead
into an infinite recursion. Read the chapter on left recursion
elimination.

The error message you should not see

you found a bug
Indicates a bug in Gray. See the chapter on feature reports

Warnings

conflict: conflict-set
(The conflict-set is printed as a sequence of numbers. If you want to
print it in a different way, store your token-printing word (token -- )
in the variable print-token.) Parsers with conflicts often don't
understand the language, i.e. they cannot parse all sentences.
Therefore you should investigate every conflict carefully and take the
appropriate actions (See the chapter on left factoring).

If the parser has to decide (e.g. between repeating another time or
not), but there are tokens that both alternatives can begin with, then
there's a conflict and these tokens are the conflict set.
	(( "a" ??  "a" ))
should parse "a" and "aa", but when the parser sees "a"'s token, it
does not know, whether this is the first or the second a. Whatever
decision it makes, it might be wrong.


The other warnings are less severe; they indicate that there are
several ways to derive eps. The resulting parser parses the same
language, but actions may be executed in a different way than you
intended.

warning: two branches may be empty
Several branches of an alternative can derive eps. The first is
chosen.

warning: unnecessary option
You made an expression optional that already derives eps.

warning: *-repetition of optional term
You *-repeated an expression that can derive eps.


MASSAGING GRAMMARS

To get rid of left recursions and conflicts you can change the
grammar to a new one that derives the same language but does not have
the problems. However, that's not always possible. I will give only
simple examples, you can find algorithms in the literature (e.g.
Alfred V. Aho, Ravi Sethi, Jeffrey D. Ullman; Compilers. Principles,
Techniques nad Tools; Addison-Wesley 1986).

Left recursion elimination

Simple left recursions look like this:
	nonterminal N
	(( N a || b )) N rule
N derives b, ba, baa, ..., and the sequence above can be replaced by
	(( b  a ** )) <- N

Left factoring

In
	(( a b || a c || d ))
there is a conflict between the first and the second branch. It can be
resolved by postponing the decision:
	(( a (( b || c )) || d ))
Often the Situation is more complex and requires heavy transformations
of the grammar, which makes it hard to read and difficult to use for
translation purposes. You should investigate other ways to resolve
conflicts, e.g. making the scanner more powerful and/or using semantic
parsing conditions (graycond.fs).


ERROR HANDLING

Gray provides no special help for error handling. The simplest way is
to print a meaningful error message, clean up and abort. One
possibility for meaningful messages is printing the set of symbols
that the parser expected. This set is the union of all the sets tested
with test? since reading the latest terminal-symbol. See calc.f83 for
an example.

A technique that allows the parser to continue when it encounters
common errors are error rules (error productions). You extend the
grammar to allow the parser to parse sentences with common errors.
When parsing an error the parser should print an error message.
Example: Statements in Pascal are separated by semicolons:
	(( statement (( ";" statement )) ** )) <- StatementSequence
This semicolon is often forgotten. If you don't want the compiler to
abort just because of a missing ";", change the rule to
	(( statement
	   (( (( ";" || {{ pascal-error ." ; inserted" }} )) statement ))
	)) <- StatementSequence

See the literature for other error recovery techniques.


THE GUTS OF GRAY

As Forth programmer you will want to change or extend Gray. Here's a
small overview to make it easier.

When reading the grammar words like "terminal", "??", "<-" and "))"
build an abstract syntax graph (ASG) of the grammar in memory. For
most grammar constructions one node is generated; to make later work
easier concatenation and alternative are translated into n-1 binary
nodes using the binary operators "concat" and "alt".

"parser" generates the parser in two passes: "propagate" just computes
the follow sets (the follow set of an expression contains the tokens
of the terminal symbols that can follow the expression. Follow sets are
only needed for recognizing conflicts). "pass2" computes the necessary
first sets, detects errors and warnings and generates code for all
rules (a first set contains the tokens of the terminals a grammar
expression can begin with. If the expression can derive eps, the
first set also contains eps. Since Grays sets can only contain tokens,
epsilon-derivations are indicated by the extra flag maybe-empty).
Finally, "parser" generates code for the start expression (the operand
of "parser").

There are small subpasses for first set computation ("compute") and
code generation ("generate"), that walk over the parts of the ASG that
they need. To save a lot of computation every ASG-node memoizes the
result of "compute". "compute" also detects left recursions and
warnings: A nonterminal comes up twice in a computation, iff there is
a left recursion. Therefore, to detect all left recursions, "compute"
is called for every node.

To avoid obscure swap-drop-flip-flop-orgies I used a context stack (It
has nothing to do with forth's "context").  The ASG-node of the
current expression is on top of this stack and can be accessed with
"this". You can access the fields of this node just by mentioning
their names. This implies that for accessing such fields you have to
push the node on the context-stack first.

Another programming technique used in Gray are methods and maps.
"compute", "generate", "propagate" and "pass2" have general functions
as well as functions specific to the node type. The special code is
called via an execution address table (map) that the "methods" field
of "this" points to. Words defined with "method" automagically execute
this calling procedure.

Code and data structure sharing impose a class hierarchy on the node
types:

syntax-expr
	terminal
	eps
	nt (nonterminal)
	action
	unary
		option&repetition
			option
			repetition
				*repetition
				+repetition
	binary
		concatenation
		alternative


GLOSSARY
doesn't contain everything

Words for building grammars
Words shown in the table in the "grammars" chapter are not shown here.

concat	( syntax-expr1 syntax-expr2 -- syntax-expr )
alt	( syntax-expr1 syntax-expr2 -- syntax-expr )
	binary postfix operators for concatenation and alternative
(-,-)	( use: (- syntax-expr1 ... -);  -- syntax-expr )
	another concatenation notation; same as (( syntax-expr1 ... ))
(|,|)	( use: (| syntax-expr1 ... |);  -- syntax-expr )
	another alternative notation; same as (( syntax-expr1 || ... ))
terminal ( use: terminal name; set check&read -- )
	defines name ( -- syntax-expr ) as terminal with first-set
	"set" and parse-time action check&read ( f -- ). See section
	"Terminals and the I/O Interface". 
nonterminal ( use: nonterminal name;  -- )
	declares name ( -- syntax-expr ) as nonterminal. See section
	"Nonterminals and Rules".
rule	( syntax-expr nt -- )
	makes "nt" an abbreviation for "syntax-expr".
<-	( use: <- name; syntax-expr -- )
	defines "name" ( -- syntax-expr2 ) as abbreviation for
	"syntax-expr".

Words necessary for parser generation

max-member ( u -- )
	declares u to be the maximum member of sets generated
	later. Must be called before using any set word except
	"member?" and thus before building a grammar.
test-vector ( a variable initially containing ' abort )
	before you call "parser", you should store into test-vector
	the execution address of a word ( set -- f ) that returns true
	if the token of the current symbol is in "set". 
parser	( use: parser name; syntax-expr -- )
	generates a parser for syntax-expr that you can call by
	"name".

Set words

max-member ( u -- )
	declares u to be the maximum member of sets generated
	later. Must be called before using any set word except
	"member?".
empty	( -- set )
	the empty set of the current size.
singleton ( u -- set )
	makes a set that contains u and nothing else
union	( set1 set2 -- set )
intersection ( set1 set2 -- set )
	set operations
member?	( set u -- f )
	returns true if u is in set
subset?	( set1 set2 -- f )
	returns true if every member of set1 is in set2
disjoint? ( set1 set2 -- f )
	returns true if set1 and set2 heve no common members
apply-to-members ( set [ u -- ] -- )
	executes [ u -- ] for every member of set

Compilation words

compile-test ( set -- )
	compiles a test for "set" using "test-vector"

Context Management

new-context ( syntax-expr -- )
old-context ( -- )
	push and pop respectively
this	( -- syntax-expr )
	the current syntax-expr, i.e. top of context-stack

Warnings and Errors

.in	( -- )
	print source location of "this", i.e. where the error
	happened.
gray-error ( -- )
	aborts
check-conflict ( set1 set2 -- )
	prints a warning if set1 and set2 conflict (are not disjoint)
	
Syntax Expression Operations
You have to substitute a class name for ... in the following words.

make-syntax-expr ( map -- syntax-expr )
make-terminal ( first-set execution-addr -- syntax-expr )
make-binary ( syntax-expr1 syntax-expr2 map -- syntax-expr )
make-unary ( syntax-expr1 map -- syntax-expr2 )
make-nt ( syntax-expr -- nt )
concat, alt, ??, ++, **, etc.
	allocate an ASG node and initialize it. "make-terminal" and
	"make-nt" are anonymous versions of the defining words.

compute	( syntax-expr -- first-set maybe-empty )
	compute the first-set and maybe-empty of syntax-expr
get-first ( syntax-expr -- first-set )
	compute just the first set of syntax-expr
check-cycle ( syntax-expr -- )
	just check for left recursion
propagate ( follow-set syntax-expr -- )
	add "follow-set" to the follow set of "syntax-expr" and its
	children
generate ( syntax-expr -- )
	generate code for "syntax-expr"
pass2	( syntax-expr -- )
	computes all necessary first sets, checks for left recursions
	and conflicts and generates code for rules
...-syntax-expr ( -- n )
	a constant containing the length of a ... ASG node
...-map	( a "create"d word )
	contains the method pointers for ...
compute-... ( -- first maybe-empty )
propagate-... ( follow-set -- )
generate-... ( -- )
pass2-... ( -- )
	execute the ...-specific part of compute, propagate, generate
	and pass2. The syntax-expr treated is "this".


AN EXAMPLE OF AN EXTENSION

In Pascal and similar languages there are many expressions of the type
	(( a  (( b a )) ** ))
Let's call them lists. The experienced programmer will immediately
factor out the common things and introduce a new operator: &&, as in
	a b &&
You can define this operator to be just an abbreviation:
	: && ( syntax-expr1 syntax-expr2 -> syntax-expr3 )
		over concat ** concat ;
(I use concat here since the parenthesized notation needs more stack
manipulation.)
When you use this operator, two pointers to syntax-expr1 are generated.
This is OK. Cycles, however, must contain nonterminals to avoid
infinite recursions in generate.
The definition of && is good enough for nearly everything, but for the
sake of the example, let's do a version that generates
    begin [ a generate ] ... test? while [ b generate ] repeat
instead of
    [ a generate ] begin ... test? while [ b generate a generate ] repeat
You find the program described here in graylist.f83.
"&&" makes a binary node with an additional field that is explained
later. Its map points to list-specific words that we have to define
now:

"generate-list" is the easiest, since we know already what it should
do. The only thing unknown is the set, that is to be tested: There
should be another repetition, if the next token is in the first set of
( b a ). Thus, the set to be tested is the first set of b; if b can
derive epsilon, b is transparent and the first-set of a has to be
added. Since no memory may be allocated while "generate"ing, set
operations like "union" are forbidden. Therefore the set is computed
in pass2-list and stored in the field "test-set".

The next task is "compute-list". If a cannot derive epsilon, the first
set of the expression is the first set of a. If a can derive epsilon,
the expression can begin with b and b's first set has to be added. The
expression derives epsilon, if a derives epsilon.

"propagate-list" is quite different from "compute-list": The followset
is passed in, and it must pass the follow-sets to a and b. If no
operand derives epsilon, the follow set of b is the first set of a and
the follow set of a is the first set of b united with the follow set
of the whole expression. If an operand derives epsilon, its follow set
shines through and must be added to the follow set of the other
operand.

"pass2-list" has to recognize conflicts, compute test-set and call
"pass2" for the operands. The latter task is the same for all binary
nodes and is performed by pass2-binary. There's a conflict, if a
decision has to be made and there are tokens that both alternatives
begin with. In our case the parser has to decide between another
repetition or ceasing to parse the expression. The sets of tokens that
these alternatives begin with are the test-set and the follow set of
the expression respectively. If these sets are not disjoint, then
there is a conflict and the intersection of these sets is the conflict
set.


KNOWN FEATURES

As usual in Forth, syntax error checking is minimal. You can find some
errors (e.g. missing parentheses) by checking the stack for superfluous
cells.
Warnings and error messages are printed even if the problem cannot
show up due to the disambiguating rules.


FEATURE REPORTS

If you find a new feature, mail a report to

anton@mips.complang.tuwien.ac.at

In this report you should describe the behaviour that constitutes the
feature and how to reproduce this behaviour (A program would be nice).


AUTHOR

M. Anton Ertl
Wiedner Hauptstrasse 141/1/16
A-1050 WIEN
AUSTRIA
Email:	anton@mips.complang.tuwien.ac.at

The ANS Forth code for storing and printing the source location was
written by Marcel Hendrix (mhx@forth-ev.de).

If you find Gray useful, you might want to send me a contribution.
Send it by international money order (to my address) or in cash,
foreign checks cost me $7-$8 to convert into cash.


RELATED WORK

Mikael Patel (mip@ida.liu.se) sent me a parser generator (or rather
parser interpreter), that's based upon top-down parsing with
backtracking. The code seemed quite TILE-specific, so it's probably
hard to port.

In "A User Definable Language Interface for Forth" (Journal of Forth
Application and Research (JFAR) 6/1 (1990)) Tyler A. Ivanco and
Geoffry Hunter describe two parser generators, both based upon
top-down-parsing: the first one seems to be similar to Gray, i.e. it
generates a recursive descent parser. The other one consists of two
parts: A Pascal program that generates a parsing table, and a Forth
program that interprets it. You can reach the authors at
FS3200022@sol.yocku.ca or tyler@stpl.ists.ca.

In "A BNF Parser in Forth" (SigForth Newsletter 2/2 (December 1990))
Brad Rodriguez (bradford@maccs.dcss.mcmaster.ca, B.RODRIGUEZ2 on
GEnie) describes top-down parsing with backtracking in Forth; the
article includes a listing.
