#+Title: Porting F68KANS

* General


People working on applications should never read this document. It 
adresses the system  developer, who has to port F68KANS to a new 
machine and to bring the features of the system to the application 
developer.

To do the things shown here, more than F68KANS is necessary. You 
typically will need the tools of a system developer like an 
assembler or C-Compiler. Additionly, one will need the knowlegde 
how to use these things. Dealing with this document means to leave 
the security of Forth programming.  


The primary idea of F68KANS was to obtain system, which is easy to 
port to a variaty of machines with same CPU.
To reach this goal, some precautions have been taken in the basic 
design. A portable system has to fulfill the following:

 - Being independent from the special I/O-capabilities of a special
   machine.
 - Being independent from any address konfiguration in order to avoid
   complicated mechanisms of loading.

Both has been achieved with F68KANS. Even more: F68KANS allows in 
spite of its system independence a complete usage of every special 
system resource.

To make this possible F68KANS divides into two basic parts:

 - The Forth-Kernel (called the 'system` itself). This part typically
   comes as a binary file. All Forth definitions of the user a
   contained in this file. Unless introduced explicitely by the
   programmer, this file does not contain any reference to a special
   machine or operating environment.

 - The loader, which connects the 'system' to the environment. This
   program may be very simple up to very complex depending on the
   volume of system resources it gives the system and the the
   developement environment.

Now this document explains the task of the loader and the 
interface between the loader and the system in detail. Knowing 
these things is important for porting the complete F68KANS 
environment to a new machine or just extending the existing 
functionality. 

The structures in mermory I will explain in the form of 
C-sourcecode, because it is widely spread and really near to 
pseudocode.

To study this document I suggest to print out the content of the 
file 'LOADER.C' from the original Atari-loader and to follow the 
explanation in the example of this implementation.

* Loading the system

The first task of the loader is to load the binary image of the system
into the main memory of the computer. In case that some parts of the
system are already in ROM the loader has to take care that these parts
are initialized appropriatly.  The forth-system consists of two parts:

 - the code segment
 - the data segment

In most cases both parts together with a header are stored in one 
binary file. This is the form of my distribution. The header is of 
the following format: 
#+BEGIN_EXAMPLE
	struct header
		{
          int magic;
          unsigned long codesize;
          unsigned long datasize;
          int dont_care[9];
        } header; 
#+END_EXAMPLE

I have not chosen this format by accident, but it is the default 
header of a file generated by a assembler in my Atari system.

The first two bytes contain a 'magic number' which allow the loader to
recognize a valid F68KANS image file. In the distribution delivered by
myself these to bytes contain the two characters 'JP', which are the
initials of my name.

The two following long-values (4 bytes) contain the lengths of the
code- and data-segments as they are following in the file.  The next
18 bytes following are without any meaning. Together, the header has a
total length of 28 bytes.

After analyzing the header, the loader has to carefully store the two
segments into the main memory. For that, two buffers of appropriate
size have to be allocated. When choosing the size of these buffers,
one should think of the things one intends to do with the system. It
is important to know that F68KANS strictly seperates code and
data. This means that applications compiling a lot of code but using
only few data need a large code-segment.  Applications handling large
amounts of data (see ALLOT) or simply generating large numbers of
Forth-words (headers are data!) will need a large data-segment.
Needless to say that the buffers have to be greater than the segments
and may not intersect.

After allocating the buffers, simply load the corresponding parts of
the file into the buffers. If you do not intend to compile anything
you may write-protect the code-segment.

Now not all concerning memory is done. F68KANS needs additional memory
areas for data- and return-stack as well as for the terminal input
buffer TIB. I suggest 2kB for the datastack, about 1kB for the
returnstack and 256 bytes for the TIB.

Now having all necessary addresses it is time the make F68KANS taking
notice of them. Therefore exits a structure, which later is passed as
a parameter to the system. One has to store all the pointers into this
structure:
#+BEGIN_EXAMPLE   
	typedef struct {
		long registers[16];		/* to be filled by F68K */
 		void *data;				/* A3 */
		void *code;				/* A5 */
		void *datastack;		/* A6 */
		void *retstack;  		/* A7 */
		void *TIBptr; 	
		long codelen;
		long datalen;
		SI_group *si;
	} FORTHPARAS; 

	FORTHPARAS forthparas; 
#+END_EXAMPLE

The first entry =registers[]= is filled by F68KANS itself when
initializing. It is filled with the contents of the registers.  This
shall give loaders in critical environments the possibility to use the
register context of the loader when executing loader functions.

The following two entries are pointers containing the addresses of
code- and data-segment. The three next contain the addresses of data-
and return-stack and of TIB. The variables codelen and datalen do not
contain the lengths of the segments found in the file but the size of
the corresponding buffers in memory.  The last entry *si is of
interest in the following chapters.

When the structure is filled so far one can say the system is
loaded. Now one has to submit some basic I/O-functions.

* Basic I/O

A standard F68KANS binary image contains no information on how to emit
or receive a single character. These things are for a textoriented
system of some importance.  On the other hand, the handling of I/O is
very system dependent.  for this reason all necessary functions are
provided by the loader program. While initializing F68KANS stores the
pointers to these functions into internal variables, so that they can
be used for all I/O. To make this work there some precautions that the
I/O-functions must hold to interface with F68KANS.


Four functions are necessary:

 | KEY   | Receive single character      |
 | EMIT  | Emit single character         |
 | KEY?  | Check input state of console  |
 | EMIT? | Check output state of console |

That's all! F68KANS will do as a basis system even with only first
two.

With the definition of the parameter interface I oriented myself at
mechanisms my C-compiler is using, taking not into account some it's
special features. This make me hope that the interface my be realized
under different systems in the same was.

To say it the short way:

 - all functions get theire parameters on the 68k's returnstack,
   addressed with register A7. All values on this stack are 32
   bit. This is true also for the interfaces to external libraries
   described later.
 - all functions return only one value of 32 bit. This value comes in
   register D0.

Example:

KEY gets no parameter from Forth. So the returnstack is not 
important. But KEY returns the character read expanded to 32 bit.

#+BEGIN_EXAMPLE
	long cdecl key(void);
	{
		return (long)Bconin(CONSOLE);
	} 
#+END_EXAMPLE

On the other hand, EMIT returns nothing, but takes one parameter 
(the character to emit) from the stack, which has to be long:

#+BEGIN_EXAMPLE
	void cdecl emit(ch)   
	long ch;
	{
		Bconout(CONSOLE,(int)ch);
	} 
#+END_EXAMPLE

People used to C may have noticed the 'cdecl' modifier. By this
modifier MY C-compiler is forced to handle parameters on the
stack. Otherwise it would expect parameters in registers, which cannot
be provided by F68KANS.

Using this convention ist extremely important! Otherwise F68KANS will
not run under any circumstances!

If you cannot force your C-compiler using this conventions, you will
have to take a different compiler or to enclose your functions in
little assembler modules. If you write our loader in assembler anyway,
you should not have any problems at all.

Similar to the things to do with the memory segments, F68KANS has to
take notice from the functions. For this reason there exists the most
complex structure in the whole business. This structure is of further
importance when using additional library functions.

In the same structure, where you laid down all the memory parameters,
there is a pointer to a structure of type 'SI_group'.  'SI'is an
acronym for 'System Interface'. This pointer consequently points to a
group of system interfaces. 'Group' means that it points to a further
field of pointer, which then point to the SI themselves.
 

Such a SI has the following structure:

#+BEGIN_EXAMPLE
	typedef void* cdecl SI_funcarr;
	typedef struct { 	
		char  		SI_id[4];
		SI_funcarr 	SI_fa;
 	} SI_group; 
#+END_EXAMPLE

A SI consists alway of a unique identifier of four character and
following a pointer to a field of functions. So a set of functions can
be taken together under a describing name (e.g. BIOS, GRAF,
FLOT). With this name F68KANS later can find out, wether a special
loader offers the functions it needs to execute somme special
functionality. So, if there is a loader for a text terminal without
graphics, F68KANS can find out this fact and will not perform any
graphics program.
 

To achieve it's basic functionality, there always has to be at least
one SI named 'BIOS'. Additionaly, the 'BIOS'-SI has to be the first
entry in the pointer array. In my C-source it looks like this:

#+BEGIN_EXAMPLE
	SI_funcarr SI_BIOS_fa[] = {
		key, 
		key_quest, 
		emit, 
		emit_quest
	};   


	SI_group SI[2];

	/*
	 * initialisation of system interface
	 */
	strcpy(SI[0].SI_id, "BIOS");
	SI[0].SI_fa = SI_BIOS_fa; 

	strcpy(SI[1].SI_id, "    ");
	SI[1].SI_fa = NULL; 

#+END_EXAMPLE

First, the array of functions is filled with the necessary BIOS
functions. The the array of all SI's is allocated and then filled with
the appropriate values. You can see that the string 'BIOS' and and the
pointer to the array of functions SI_BIOS_fa is placed into the 0th
SI-entry.  There always has to be one additional dummy SI with four
spaces as its name. The entry is used a end-of-list sign when using
multiple SI.

At last, the address of the SI has to be written to the 
FORTHPARAS-structure:
#+BEGIN_EXAMPLE
	forthparas.si	 = SI; 
#+END_EXAMPLE

* Starting the System 

All is prepared now. A simple jump to the start of the codesegment
after pushing the address of the FORTHPARAS-structure to the
returnstack should make F68KANS runs:

#+BEGIN_EXAMPLE
	typedef void cdecl FUNC(FORTHPARAS*); 
	(*(FUNC*)codeseg)(&forthparas); 
#+END_EXAMPLE

Now F68KANS looks for the first pointer in the SI-field and checks
wether it finds the name 'BIOS'. If not, F68KANS stops and returns to
the loader. When it finds the 'BIOS'-SI, it copies the four pointer
into internal vectors and use them for its I/O performed by KEY and
EMIT.

After that, all the memory parameters are evaluated and copied into
the appropriate registers and internal variables.

* Using extended functionality

Many forth systems suffer from the fact, that they are closes systems
which, when they are good, allow access to the basic resources of the
environment. But what happens, when a very good new graphic library
appears??

In this case, F68KANS offers the opportunity to extend the loader with
the desired functionality. I myself used this opportunity to implement
many system functions (file, float, ...) in an extensive way, because
the libraries I have for that are much better than I can ever do it
myself. And: I avoid reinventing the wheel.

How does the work?

By adding new system interfaces, of course!

One simply has to add the interface described above the all functions
needed. As an example I will show some interface definitions for some
standard C-functions:

#+BEGIN_EXAMPLE
	void *cdecl _fopen( char *filename, long len, 
						char *mode, long mlen )
	{ 
	char str1[256];
	char str2[256];

		memcpy( str1, filename, (size_t)len );
		str1[len] = '\0'; 	
		memcpy( str2, mode, (size_t)mlen );
		str2[mlen] = '\0'; 	
	
		return (void *)fopen( str1, str2 ); 
	}


	long cdecl _fputc( long ch, void *file )
	{ return (long)fputc( (int)ch, (FILE*)file ); }


	long cdecl _fputs( char *s, long len, void *file )
	{ 
	char str[256];

		memcpy( str, s, (size_t)len );
		str[len] = '\0'; 	
		return (long)fputs( str, (FILE*)file ); 
	}


	long cdecl _fread( void *ptr, long size, 
						long count, void *file )
	{ 
		return (long)fread( ptr, (size_t)size, 
							(size_t)count, (FILE*)file ); 
	} 
#+END_EXAMPLE

In a similar way to 'BIOS' a new SI named 'CLIB' is created and 
added to the list of the other SIs:

#+BEGIN_EXAMPLE
	SI_group SI[3];

	/*
	 * initialisation of system interface
	 */
	strcpy(SI[0].SI_id, "BIOS");
	SI[0].SI_fa = SI_BIOS_fa; 

	strcpy(SI[1].SI_id, "CLIB");
	SI[1].SI_fa = SI_CLIB_fa; 

	strcpy(SI[2].SI_id, "    ");
	SI[2].SI_fa = NULL; 
#+END_EXAMPLE

In contrast to 'BIOS', now on Forth-side there has to be a
mechanismen, which finds, evaluates and executes the new functions in
the new SI. This has been implemented with some very simple Forth
words.

The most important is the defining word 'systeminterface'. It is used
this way:

#+BEGIN_EXAMPLE
	systeminterface initCLIB CLIB  CONSTANT CLIBBASE  
#+END_EXAMPLE

With that, the later very important word 'initCLIB' and the constant
'CLIBBASE' are defined.

'initCLIB' is created using the name of the SI 'CLIB'. This word
always has to be executed before using any of the new functions.
'initCLIB' checks, wether the 'CLIB'-SI is present and initializes the
SI by storing its address into an internal variable.  This is
necessary, because the forth words to be defined, which execute the
library functions, access these using only an index to the array of
functions. The base address of this array may change from session to
session.

The Forth-words executing the functions have to handle the parameters
correctly. So there is a simple parameter description.  By default,
three different types of input parameters are possible:


 | _n | Integer |
 | _a | Address |
 | _s | String  |

Notice the underscores!! They are part of the name!

There are four different output parameters:

 | nothing | No returnvalue |
 | outint  | Integer        |
 | outptr  | Address        |
 | outstr  | String         |


Strings are common Forth-strings identified by address and length.

Now, to define a library-function-executing-word there is the defining
word 'SI:'. It creates a word with a given name, which calles the
corresponding function with given parameter description:

#+BEGIN_EXAMPLE
	CLIBBASE 0
			_n	SI: _fgetc	outint ( FILE* -- char )
		_n	_a	SI: _fgetpos outint ( FILE* long* -- ior )
	_a	_n	_n	SI: _fgets	outstr ( char* n FILE* -- c-addr u )
			_n	SI:	_fileno	outint ( FILE* -- handle )
		_s	_s	SI: _fopen	outint 
							( c-addr1 u1 c-addr2 u2 -- FILE* )
		_n	_n	SI:	_fputc	outint ( char FILE* -- char )
		_s	_n	SI:	_fputs	outint ( c-addr u FILE* -- len2 )   
	2DROP
#+END_EXAMPLE

(Note that 'FILE*' beeing a real pointer is handled as a simple
integer on Forth-side, because the pointer itself does not have any
meaning for Forth and a NULL-pointer (FILE* == NULL) evaluates to a
integer 0).

You now can use the functions '_fputs' as follows: 

#+BEGIN_EXAMPLE
	S" Hello World!"  FILEID @  _fputs   . 
#+END_EXAMPLE

The constant CLIBBASE will never be used any more, so that you may
skip its definition. Here it has be defined for clarity only.

I think, these examples show the usage of the interface to a
sufficient extent.


The only critical point in the business is that you have to take care
that the order of the functions in the SI-array of functions and in
the Forth declaration is the same.

Before using the new functions it is important that the initializing
word defined by 'systeminterface' ('initCLIB') REALLY has been
executed. Otherwise F68KANS may crash! This is even more important,
when the system has been saved by 'SAVE-SYSTEM'. The initializing
words have to be executed at the start of EVERY session. I myself fell
into this trap several times and started to look for bug in the
library functions or the definition of the interface. So: be
carefull!!
